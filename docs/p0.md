# Project 0: Getting Real

## Preliminaries

>Fill in your name and email address.

Evgenii Stankevich <stankevich.evg@gmail.com>

>If you have any preliminary comments on your submission, notes for the TAs, please give them here.

No

>Please cite any offline or online sources you consulted while preparing your submission, other than the Pintos documentation, course text, lecture notes, and course staff.

- https://en.wikipedia.org/wiki/Booting#Boot_sequence_on_standard_PC_.28IBM-PC_compatible.29
- https://stackoverflow.com/questions/3274014/0xffff0-and-the-bios
- https://www.cs.cmu.edu/afs/gco/archive/twiki/pub/Main/PoornimaKamath/pintos_gdb.pdf
- https://en.wikipedia.org/wiki/X86_memory_segmentation
- https://en.wikipedia.org/wiki/BIOS_interrupt_call
- https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html
- https://en.wikipedia.org/wiki/Master_boot_record
- https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=42h:_Extended_Read_Sectors_From_Drive


## Booting Pintos

>A1: Put the screenshot of Pintos running example here.

```
qemu-system-i386: QEMU: Terminated via GDBstub
root@88d4508e0546:~/pintos/src/threads/build# pintos --gdb -- run alarm-priority
qemu-system-i386 -device isa-debug-exit -drive format=raw,media=disk,index=0,file=/tmp/7QGhfT9nj6.dsk -m 4 -net none -nographic -gdb tcp::1234 -S
Pintos hda1
Loading...........
Kernel command line: run alarm-priority
Pintos booting with 3,968 kB RAM...
367 pages available in kernel pool.
367 pages available in user pool.
Calibrating timer...  209,510,400 loops/s.
Boot complete.
```

## Debugging

#### QUESTIONS: BIOS 

>B1: What is the first instruction that gets executed?

By convention first address contains jump to the first BIOS instruction
```
[f000:fff0]    0xffff0: ljmp   $0x3630,$0xf000e05b
```

>B2: At which physical address is this instruction located?

```
0xffff0 (f000 << 4 + fff0)
```

#### QUESTIONS: BOOTLOADER

>B3: How does the bootloader read disk sectors? In particular, what BIOS interrupt is used?

It iterates disks and reads first sector.

Extended Read Sectors From Drive Interrupt is used:
https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=42h:_Extended_Read_Sectors_From_Drive

There are 4 parameters (registers) as input for interrupt:
AH - function number (42h)
DL - Drive index
DS:SI - memory buffer (see the link for details)

This interrapt is called from `read_sector` subroutine:

```
mov $0x42, %ah			# Extended read
mov %sp, %si			# DS:SI -> packet
int $0x13			    # Error code in CF
```

Interesting that this interrupt puts error code to flag `CF` wich is then used for conditional jump `jc`:

```
jc no_such_drive
```

In other words if interrupt sets `CF` it means we can not find partition.

>B4: How does the bootloader decides whether it successfully finds the Pintos kernel?

It checks magic bits in MBR record (https://en.wikipedia.org/wiki/Master_boot_record)
```
    # Is it a Pintos kernel partition?
	cmpb $0x20, %es:4(%si)
```

Partition entry has 16 bytes, we read 4th to get partition type. We consider that for Pintos kernel type is 0x20.


>B5: What happens when the bootloader could not find the Pintos kernel?

It calls BIOS interrapt 18h

```
	# Notify BIOS that boot failed.  See [IntrList].
	int $0x18
```

From https://en.wikipedia.org/wiki/BIOS_interrupt_call:

Execute Cassette BASIC: On IBM machines up to the early PS/2 line, this interrupt would start the ROM Cassette BASIC. Clones did not have this feature and different machines/BIOSes would perform a variety of different actions if INT 18h was executed, most commonly an error message stating that no bootable disk was present. Modern machines would attempt to boot from a network through this interrupt. On modern machines this interrupt will be treated by the BIOS as a signal from the bootloader that it failed to complete its task. The BIOS can then take appropriate next steps.

>B6: At what point and how exactly does the bootloader transfer control to the Pintos kernel?

After kernel is loaded, loader calculates start method address, put it to memory and executes `ljump` transfering controll to start defined in start.S file.

#### QUESTIONS: KERNEL

>B7: At the entry of pintos_init(), what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?

```
(gdb) print/x init_page_dir[pd_no(ptov(0))]
=> 0xc000efef:  int3   
=> 0xc000efef:  int3   
$8 = 0x0
```

>B8: When `palloc_get_page()` is called for the first time,

>> B8.1 what does the call stack look like?
>>
>> 

```
(gdb) where
#0  palloc_get_page (flags=(PAL_ASSERT | PAL_ZERO)) at ../../threads/palloc.c:112
#1  0xc00203aa in paging_init () at ../../threads/init.c:168
#2  0xc002031b in pintos_init () at ../../threads/init.c:100
#3  0xc002013d in start () at ../../threads/start.S:180
```

>> B8.2 what is the return value in hexadecimal format?
>>
>> 

```
(gdb) print/x palloc_get_multiple (flags, 1)
=> 0xc000ef8f:  int3   
$9 = 0xc0101000
```

>> B8.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> 

```
(gdb) print/x init_page_dir[pd_no(ptov(0))]
=> 0xc000ef8f:  int3   
=> 0xc000ef8f:  int3   
$10 = 0x0
```

>B9: When palloc_get_page() is called for the third time,

>> B9.1 what does the call stack look like?
>>
>> 

```
(gdb) where
#0  palloc_get_page (flags=PAL_ZERO) at ../../threads/palloc.c:112
#1  0xc0020a81 in thread_create (name=0xc002e895 "idle", priority=0, function=0xc0020eb0 <idle>, aux=0xc000efbc) at ../../threads/thread.c:178
#2  0xc0020976 in thread_start () at ../../threads/thread.c:111
#3  0xc0020334 in pintos_init () at ../../threads/init.c:119
#4  0xc002013d in start () at ../../threads/start.S:180
```

>> B9.2 what is the return value in hexadecimal format?
>>
>> 

```
(gdb) print/x palloc_get_multiple (flags, 1)
=> 0xc000ef4f:  int3   
$11 = 0xc0104000
```

>> B9.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> 

```
(gdb) print/x init_page_dir[pd_no(ptov(0))]
=> 0xc000ef4f:  int3   
=> 0xc000ef4f:  int3   
$12 = 0x103027
```

## Kernel Monitor

>C1: Put the screenshot of your kernel monitor running example here. (It should show how your kernel shell respond to `whoami`, `exit`, and `other input`.)

#### 

>C2: Explain how you read and write to the console for the kernel monitor.
